<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="icon" href="isagi.jpg" type="image/jpg">
  <meta charset="UTF-8">
  <title>FINAL TIMETABLE</title>
  <style>
    /* Import a modern monospaced font */
    @import url('https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;700&display=swap');
  
    :root {
      /* === Futuristic Color Palette === */
      --dark-bg: #000000; /* Deep space black */
      --neon-purple: #e2a82b; /* Vibrant purple */
      --neon-pink: #ff0000; /* Electric pink */
      --neon-blue: #00ffff; /* Cyan blue */
      --accent: #00e5ff; /* Bright teal */
      --hologram-green: #39ff14; /* Matrix green */
      --cyber-yellow: #ffd700; /* Futuristic gold */
      --glow: 0 0 20px rgba(255, 255, 255, 0.5); /* Base glow effect */
  
      /* === Advanced Effects === */
      --hologram-gradient: linear-gradient(
        135deg,
        var(--neon-purple) 0%,
        var(--neon-pink) 50%,
        var(--neon-blue) 100%
      );
      --neon-glow: 0 0 10px var(--neon-purple), 0 0 20px var(--neon-pink),
        0 0 30px var(--neon-blue), 0 0 40px var(--accent);
      --pulse-animation: pulse 2s infinite ease-in-out;
      --scanline-animation: scanline 5s linear infinite;
      /* ---- Added from Code 1 ---- */
      --flicker-animation: flicker 3s infinite;
  
      /* === Typography & Sizing === */
      --font-primary: "Fira Code", monospace;
      --font-secondary: "Orbitron", sans-serif; /* Futuristic font */
      --transition-speed: 0.3s;
      --border-radius: 12px; /* Rounded futuristic edges */
      --panel-bg: rgba(0, 0, 0, 0.9); /* Semi-transparent black */
      --glass-effect: rgba(255, 255, 255, 0.1); /* Glassmorphism effect */
      --blur-effect: blur(10px); /* Blur for glass effect */
    }
  
    /* === Keyframes for Animations === */
    @keyframes pulse {
      0% {
        box-shadow: var(--neon-glow);
      }
      50% {
        box-shadow: 0 0 30px var(--neon-purple), 0 0 50px var(--neon-pink),
          0 0 70px var(--neon-blue), 0 0 90px var(--accent);
      }
      100% {
        box-shadow: var(--neon-glow);
      }
    }
  
    @keyframes scanline {
      0% {
        background-position: 0 0;
      }
      100% {
        background-position: 0 100%;
      }
    }
  
    /* ---- Added from Code 1 ---- */
    @keyframes flicker {
      0%, 19%, 21%, 23%, 25%, 54%, 56%, 100% {
        opacity: 1;
      }
      20%, 24%, 55% {
        opacity: 0.5;
      }
    }
  
    * {
      box-sizing: border-box;
    }
  
    body {
      margin: 0;
      background: var(--dark-bg);
      min-height: 100vh;
      font-family: var(--font-primary);
      color: #fff;
      overflow-x: hidden;
      line-height: 1.6;
      position: relative;
    }
  
    /* Particle background container */
    #particles-js {
      position: fixed;
      width: 100%;
      height: 100%;
      z-index: 0;
    }
  
    /* Animated radial background */
    body::before {
      content: "";
      position: fixed;
      top: 0;
      left: 0;
      width: 200%;
      height: 200%;
      background: radial-gradient(circle at center, rgba(255,255,255,0.05), transparent 70%);
      z-index: -1;
      animation: bgShift 10s ease infinite;
    }
    @keyframes bgShift {
      0% {
        transform: translate(-25%, -25%) scale(1);
      }
      50% {
        transform: translate(-20%, -20%) scale(1.1);
      }
      100% {
        transform: translate(-25%, -25%) scale(1);
      }
    }
  
    .container {
      position: relative;
      z-index: 2;
      max-width: 1200px;
      margin: 0 auto;
      padding: 2rem;
    }
  
    .panel {
      background: var(--panel-bg);
      border: 1px solid var(--neon-purple);
      border-radius: 10px;
      padding: 2rem;
      margin: 2rem 0;
      box-shadow: var(--glow);
      animation: panelFadeIn 0.8s ease-out;
    }
    @keyframes panelFadeIn {
      from {
        opacity: 0;
        transform: scale(0.95);
      }
      to {
        opacity: 1;
        transform: scale(1);
      }
    }
  
    h1 {
      text-align: center;
      margin-bottom: 1rem;
      font-size: 2.5rem;
      text-shadow: 0 0 10px var(--neon-pink);
      animation: textGlow 1.5s ease-in-out infinite alternate;
    }
    @keyframes textGlow {
      from {
        text-shadow: 0 0 5px var(--neon-pink);
      }
      to {
        text-shadow: 0 0 20px var(--neon-pink);
      }
    }
  
    h2 {
      border-bottom: 1px solid var(--neon-purple);
      padding-bottom: 0.5rem;
      margin-bottom: 1rem;
      font-size: 1.8rem;
      position: relative;
    }
    h2::after {
      content: "";
      position: absolute;
      width: 50px;
      height: 3px;
      background: var(--neon-blue);
      left: 0;
      bottom: -5px;
      animation: slideIn 1s ease-out;
    }
    @keyframes slideIn {
      from {
        transform: translateX(-100%);
      }
      to {
        transform: translateX(0);
      }
    }
  
    .cyber-line {
      height: 2px;
      background: linear-gradient(90deg, transparent, var(--neon-purple), transparent);
      margin: 2rem 0;
    }
  
    .input-group {
      display: grid;
      grid-template-columns: 1fr auto auto auto;
      gap: 1rem;
      margin-bottom: 2rem;
    }
    input,
    textarea,
    select {
      background: rgba(255,255,255,0.1);
      border: 1px solid var(--neon-purple);
      color: white;
      padding: 12px;
      border-radius: var(--border-radius);
      transition: all var(--transition-speed) ease;
      font-size: 1rem;
    }
    input:focus,
    textarea:focus,
    select:focus {
      border-color: var(--neon-pink);
      box-shadow: var(--glow);
      outline: none;
    }
    button {
      background: linear-gradient(45deg, var(--neon-purple), var(--neon-pink));
      border: none;
      padding: 12px 24px;
      color: white;
      border-radius: var(--border-radius);
      cursor: pointer;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
      text-transform: uppercase;
      font-weight: bold;
      letter-spacing: 1px;
      font-size: 1rem;
      box-shadow: var(--glow);
    }
    button:hover {
      transform: scale(1.05);
      box-shadow: 0 0 25px var(--neon-blue);
      /* ---- Added from Code 1: Flicker effect on hover ---- */
      animation: var(--flicker-animation);
    }
  
    .empty {
      text-align: center;
      color: rgba(255,255,255,0.6);
      font-style: italic;
      padding: 1rem;
    }
  
    .task-list,
    .note-history {
      display: grid;
      gap: 1rem;
    }
  
    .task-item,
    .note-item {
      background: rgba(255,255,255,0.05);
      padding: 1.5rem;
      border-radius: 8px;
      border-left: 4px solid var(--neon-purple);
      display: flex;
      justify-content: space-between;
      align-items: center;
      animation: taskAppear 0.5s ease;
      position: relative;
      overflow: hidden;
    }
    @keyframes taskAppear {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
  
    /* Shine effect on task items */
    .task-item::before {
      content: "";
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(120deg, transparent, rgba(255,255,255,0.2), transparent);
      transform: skewX(-25deg);
    }
    .task-item:hover::before {
      animation: shine 0.75s forwards;
    }
    @keyframes shine {
      from {
        left: -100%;
      }
      to {
        left: 100%;
      }
    }
  
    .priority-tag {
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 0.8em;
      margin-bottom: 0.5rem;
      display: inline-block;
    }
    .low {
      background: rgba(0,230,118,0.2);
    }
    .medium {
      background: rgba(255,214,0,0.2);
    }
    .high {
      background: rgba(255,23,68,0.2);
    }
  
    .deadline {
      color: var(--accent);
      font-size: 0.9em;
      margin-top: 0.5rem;
    }
  
    .progress-bar {
      width: 100%;
      height: 10px;
      background: rgba(255,255,255,0.1);
      border-radius: var(--border-radius);
      overflow: hidden;
      margin-top: 0.5rem;
    }
    .progress {
      height: 100%;
      background: linear-gradient(90deg, var(--neon-purple), var(--neon-pink));
      width: 0;
      transition: width 0.5s ease;
    }
  
    .task-item button,
    .note-item button {
      background: rgba(255,23,68,0.2);
      border: 1px solid var(--neon-pink);
      padding: 8px 16px;
      border-radius: var(--border-radius);
      transition: all var(--transition-speed) ease;
      margin-left: 0.5rem;
    }
    .task-item button:hover,
    .note-item button:hover {
      background: rgba(255,23,68,0.5);
      box-shadow: var(--glow);
    }
  
    .reward-system {
      margin-top: 2rem;
      text-align: center;
      animation: fadeIn 1s ease;
    }
    @keyframes fadeIn {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }
    .reward-system h2 {
      color: var(--neon-pink);
      text-shadow: var(--glow);
      margin-bottom: 1rem;
    }
    .reward-points {
      font-size: 1.5rem;
      color: var(--accent);
    }
    /* Daily points display */
    #dailyPoints {
      font-size: 1.2rem;
      color: var(--neon-blue);
      margin-top: 0.5rem;
    }
  
    /* Center the toggle buttons */
    #toggleHistoryBtn,
    #toggleNotesBtn {
      display: block;
      margin: 1rem auto;
    }
  
    /* Settings Icon */
    #settingsIcon {
      position: fixed;
      top: 750px;
      right: 10px;
      font-size: 2rem;
      cursor: pointer;
      z-index: 1001;
    }
  
    /* Settings container */
    #settingsContainer {
      display: none;
      position: fixed;
      top: 50px;
      right: 10px;
      background: var(--panel-bg);
      border: 1px solid var(--neon-purple);
      padding: 1rem;
      border-radius: 8px;
      z-index: 1000;
    }
    #settingsContainer label {
      display: block;
      margin-bottom: 0.5rem;
    }
    #settingsContainer button {
      margin-top: 0.5rem;
    }
  
    /* Accordion effect for task history */
    .task-history {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.4s ease;
    }
    
    .task-history.open {
      max-height: 1000px;
      overflow-y: auto;  /* Yeh property scrolling enable karti hai */
    }
    
    /* Aborted task styling */
    .task-item.aborted {
      border-left-color: #ff0000;
      opacity: 0.85;
    }
  
    /* Hover glow */
    .task-item:hover,
    .note-item:hover {
      box-shadow: 0 0 30px var(--neon-blue);
    }
  
    @keyframes pulsate {
      0% {
        transform: scale(1);
      }
      50% {
        transform: scale(1.03);
      }
      100% {
        transform: scale(1);
      }
    }
    .pulsate {
      animation: pulsate 1.5s infinite;
    }
  
    /* Custom Scrollbar Styling */
    ::-webkit-scrollbar {
      width: 8px;
    }
    ::-webkit-scrollbar-track {
      background: rgba(255,255,255,0.1);
    }
    ::-webkit-scrollbar-thumb {
      background: var(--neon-purple);
      border-radius: 4px;
    }
    ::-webkit-scrollbar-thumb:hover {
      background: var(--neon-pink);
    }
  
    /* Responsive adjustments for mobile devices */
    @media (max-width: 600px) {
      .container {
        padding: 1rem;
      }
      h1 {
        font-size: 2rem;
      }
      h2 {
        font-size: 1.5rem;
      }
      .input-group {
        grid-template-columns: 1fr auto;
      }
      button {
        padding: 10px 20px;
        font-size: 0.9rem;
      }
      .task-item,
      .note-item {
        flex-direction: column;
        align-items: flex-start;
      }
      .task-item > div:last-child,
      .note-item > button {
        margin-top: 0.5rem;
      }
    }
  </style>
  
  
  
  <!-- Particles.js Library -->
  <script src="https://cdn.jsdelivr.net/particles.js/2.0.0/particles.min.js"></script>
  <!-- Canvas-confetti Library for celebrations -->
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>
</head>
<body>
  <!-- Settings Icon -->
  <div id="settingsIcon">⚙️</div>
  <!-- Settings Panel -->
  <div id="settingsContainer">
    <label>
      <input type="checkbox" id="voiceToggle" checked>
      Enable Voice Notifications
    </label>
    <button id="clearHistoryBtn">Clear Task History</button>
    <button id="resetDailyBtn">Reset Daily Points</button>
  </div>
  
  <div id="particles-js"></div>
  <div class="container">
    <div class="panel">
      <h1>MADE BY NOTURTYPE_ANASS</h1>
      <div class="cyber-line"></div>
      
      <!-- Active Missions Section -->
      <div class="task-manager">
        <h2>Active Missions</h2>
        <div class="input-group">
          <input type="text" id="taskInput" placeholder="Enter your mission...">
          <select id="priority">
            <option value="low">Low</option>
            <option value="medium">Medium</option>
            <option value="high">High</option>
          </select>
          <input type="number" id="taskTime" placeholder="Time (in minutes)" min="1">
          <button id="addTaskBtn">Add Mission</button>
        </div>
        <div class="task-list" id="taskList">
          <!-- Active tasks rendered here -->
        </div>
      </div>
      
      <div class="cyber-line"></div>
      
      <!-- Task History Section -->
      <button id="toggleHistoryBtn">Show Task History</button>
      <div class="task-history" id="taskHistoryWrapper">
        <h2>Task History</h2>
        <div class="task-list" id="taskHistory">
          <!-- Completed/aborted tasks rendered here -->
        </div>
      </div>
      
      <div class="cyber-line"></div>
      
      <!-- Notes Section (hidden by default) -->
      <button id="toggleNotesBtn">Show Notes</button>
      <div id="notesContainer" style="display: none;">
        <div class="note-system">
          <h2>Encrypted Notes</h2>
          <div class="input-group" style="grid-template-columns: 1fr auto;">
            <textarea id="noteInput" placeholder="Enter your note..."></textarea>
            <button id="addNoteBtn">Add Note</button>
          </div>
          <div class="note-history" id="noteHistory">
            <!-- Notes rendered here with Show/Hide toggle -->
          </div>
        </div>
      </div>
      
      <div class="cyber-line"></div>
      
      <!-- Reward System Section -->
      <div class="reward-system">
        <h2>Reward Points</h2>

        <div id="dailyPoints">Daily Points: 0/100</div>
      </div>
    </div>
  </div>
  <script>
    class DarkProductivityApp {
      constructor() {
        // Preload audio files
        this.sounds = {
          fifty: new Audio('progress1.mp3'),
          seventy: new Audio('progress2.mp3'),
          ninety: new Audio('progress3.mp3'),
          beep: new Audio('beep.mp3'),
          timer: new Audio('timer.mp3'),
          reminder: new Audio('reminder.mp3')
        };
  
        // Initially mute the progress audio files to bypass Chrome autoplay restrictions
        this.sounds.fifty.muted = true;
        this.sounds.seventy.muted = true;
        this.sounds.ninety.muted = true;
  
        // Flag to check if audio has been unlocked
        this.audioUnlocked = false;
  
        // Initialize state from localStorage or defaults
        this.state = {
          tasks: JSON.parse(localStorage.getItem('tasks')) || [],
          notes: JSON.parse(localStorage.getItem('notes')) || [],
          rewardPoints: parseInt(localStorage.getItem('rewardPoints')) || 0,
          dailyPoints: parseInt(localStorage.getItem('dailyPoints')) || 0,
          dailyDate: localStorage.getItem('dailyDate') || new Date().toLocaleDateString(),
          dailyGoalAchieved: false
        };
  
        // Configuration – voiceEnabled true by default
        this.config = {
          voiceEnabled: (localStorage.getItem('voiceEnabled') === null)
            ? true
            : JSON.parse(localStorage.getItem('voiceEnabled'))
        };
  
        // Reset daily points if the day has changed
        const today = new Date().toLocaleDateString();
        if (this.state.dailyDate !== today) {
          this.state.dailyPoints = 0;
          this.state.dailyDate = today;
          this.state.dailyGoalAchieved = false;
          this.saveState();
        }
  
        // History load threshold
        this.maxHistoryCount = 20;
  
        // For controlling task history display (toggle button)
        this.historyExpanded = false;
  
        this.cacheDOM();
        this.bindEvents();
        this.updateUI();
        this.updateRewardPointsDisplay();
        this.startProgressUpdateLoop();
        this.startBeepReminder();
        this.startPausedReminder();  // Start reminder for paused tasks
        this.initBackgroundAudio();
        this.requestNotificationPermission();
        this.setupVisibilityChange();
      }
  
      // Method to unlock audio on first user interaction
      unlockAudio() {
        if (this.audioUnlocked) return;
        Object.keys(this.sounds).forEach(key => {
          let sound = this.sounds[key];
          // Play and immediately pause to unlock the audio element, then unmute it
          sound.play().then(() => {
            sound.pause();
            sound.currentTime = 0;
            sound.muted = false;
          }).catch(err => {
            console.log(`Audio unlock failed for ${key}:`, err);
          });
        });
        this.audioUnlocked = true;
        console.log("Audio unlocked!");
      }
  
      cacheDOM() {
        this.taskInput = document.getElementById('taskInput');
        this.priority = document.getElementById('priority');
        this.taskTime = document.getElementById('taskTime');
        this.taskList = document.getElementById('taskList');
        this.taskHistory = document.getElementById('taskHistory');
        this.taskHistoryWrapper = document.getElementById('taskHistoryWrapper');
        this.noteInput = document.getElementById('noteInput');
        this.noteHistory = document.getElementById('noteHistory');
        this.addTaskBtn = document.getElementById('addTaskBtn');
        this.addNoteBtn = document.getElementById('addNoteBtn');
        this.toggleHistoryBtn = document.getElementById('toggleHistoryBtn');
        this.toggleNotesBtn = document.getElementById('toggleNotesBtn');
        this.settingsIcon = document.getElementById('settingsIcon');
        this.settingsContainer = document.getElementById('settingsContainer');
        this.clearHistoryBtn = document.getElementById('clearHistoryBtn');
        this.resetDailyBtn = document.getElementById('resetDailyBtn');
        this.voiceToggle = document.getElementById('voiceToggle');
        this.dailyPointsDisplay = document.getElementById('dailyPoints');
      }
  
      bindEvents() {
        this.addTaskBtn.addEventListener('click', () => this.handleAddTask());
        this.addNoteBtn.addEventListener('click', () => this.handleAddNote());
        this.toggleHistoryBtn.addEventListener('click', () => this.toggleHistory());
        this.toggleNotesBtn.addEventListener('click', () => this.toggleNotes());
        this.settingsIcon.addEventListener('click', () => this.toggleSettings());
        this.clearHistoryBtn.addEventListener('click', () => this.clearHistory());
        this.resetDailyBtn.addEventListener('click', () => this.resetDailyPoints());
        this.voiceToggle.addEventListener('change', () => {
          this.config.voiceEnabled = this.voiceToggle.checked;
          localStorage.setItem('voiceEnabled', JSON.stringify(this.config.voiceEnabled));
        });
  
        // Delegate active task actions
        this.taskList.addEventListener('click', (e) => {
          if (e.target.classList.contains('complete-task')) {
            const id = Number(e.target.dataset.id);
            this.playSound('timer');
            this.completeTask(id, true);
          } else if (e.target.classList.contains('abort-task')) {
            const id = Number(e.target.dataset.id);
            this.abortTask(id);
          } else if (e.target.classList.contains('edit-task')) {
            const id = Number(e.target.dataset.id);
            this.editTask(id);
          } else if (e.target.classList.contains('save-task')) {
            const id = Number(e.target.dataset.id);
            this.saveEditedTask(id);
          } else if (e.target.classList.contains('pause-task')) {
            const id = Number(e.target.dataset.id);
            this.pauseTask(id);
          } else if (e.target.classList.contains('resume-task')) {
            const id = Number(e.target.dataset.id);
            this.resumeTask(id);
          }
        });
  
        // Delegate deletion in history
        this.taskHistory.addEventListener('click', (e) => {
          if (e.target.classList.contains('delete-task')) {
            const id = Number(e.target.dataset.id);
            this.deleteTask(id);
          }
        });
  
        // Toggle note decryption
        this.noteHistory.addEventListener('click', (e) => {
          if (e.target.classList.contains('toggle-note')) {
            const id = Number(e.target.dataset.id);
            this.toggleNoteDecryption(id);
          }
        });
  
        // Add task on Enter (unless in note input)
        document.addEventListener('keypress', (e) => {
          if (e.key === 'Enter' && document.activeElement !== this.noteInput) {
            e.preventDefault();
            this.handleAddTask();
          }
        });
      }
  
      saveState() {
        localStorage.setItem('tasks', JSON.stringify(this.state.tasks));
        localStorage.setItem('notes', JSON.stringify(this.state.notes));
        localStorage.setItem('rewardPoints', this.state.rewardPoints);
        localStorage.setItem('dailyPoints', this.state.dailyPoints);
        localStorage.setItem('dailyDate', this.state.dailyDate);
      }
  
      handleAddTask() {
        const text = this.taskInput.value.trim();
        const time = parseInt(this.taskTime.value);
        if (!text || isNaN(time) || time <= 0) return;
        // Use activeDuration tracking
        const newTask = {
          id: Date.now(),
          text,
          priority: this.priority.value,
          time, // in minutes
          completed: false,
          aborted: false,
          progress: 0,
          startTime: Date.now(),
          totalDuration: time * 60000,  // Total required active time (ms)
          activeDuration: 0,            // Accumulated active (non-paused) time
          lastActiveTimestamp: Date.now(), // For tracking active intervals
          rewarded: false,
          prompted: false,
          awaitingResponse: false,  // To ensure we don't repeatedly prompt user
          beep50: false,
          beep70: false,
          beep90: false,
          // Pause/Resume properties
          paused: false,
          pauseStart: null
        };
        this.state.tasks.push(newTask);
        this.taskInput.value = '';
        this.taskTime.value = '';
        this.updateUI();
        this.saveState();
        this.playSound('timer');
        this.showAchievement('Timer started! Good luck!');
      }
  
      completeTask(id, manual = false) {
        const task = this.state.tasks.find(t => t.id === id);
        if (task && !task.completed && !task.aborted) {
          task.completed = true;
          task.progress = 100;
          task.actualCompletionTime = Date.now();
          if (!task.rewarded) {
            this.state.rewardPoints += 20;
            this.state.dailyPoints += 20;
            task.rewarded = true;
          }
          this.updateUI();
          this.updateRewardPointsDisplay();
          this.saveState();
          this.playSound('timer');
          this.showCelebration('Mission Accomplished!');
        }
      }
  
      abortTask(id) {
        const task = this.state.tasks.find(t => t.id === id);
        if (task && !task.completed && !task.aborted) {
          task.aborted = true;
          task.abortTime = Date.now();
          if (!task.rewarded) {
            this.state.rewardPoints -= 20;
            this.state.dailyPoints -= 20;
            task.rewarded = true;
          }
          this.updateUI();
          this.updateRewardPointsDisplay();
          this.saveState();
        }
      }
  
      deleteTask(id) {
        this.state.tasks = this.state.tasks.filter(t => t.id !== id);
        this.updateUI();
        this.saveState();
      }
  
      handleAddNote() {
        const text = this.noteInput.value.trim();
        if (!text) return;
        const encryptedText = btoa(text);
        const newNote = {
          id: Date.now(),
          text: encryptedText,
          timestamp: new Date().toLocaleString(),
          showDecrypted: false 
        };
        this.state.notes.unshift(newNote);
        this.noteInput.value = '';
        this.updateUI();
        this.saveState();
      }
  
      deleteNote(id) {
        this.state.notes = this.state.notes.filter(note => note.id !== id);
        this.updateUI();
        this.saveState();
      }
  
      toggleNoteDecryption(id) {
        const note = this.state.notes.find(note => note.id === id);
        if (note) {
          note.showDecrypted = !note.showDecrypted;
          this.updateUI();
          this.saveState();
        }
      }
  
      updateRewardPointsDisplay() {
        this.dailyPointsDisplay.textContent = `Daily Points: ${this.state.dailyPoints}/100`;
        if (this.state.dailyPoints >= 100 && !this.state.dailyGoalAchieved) {
          this.showAchievement('Daily Goal Achieved!');
          this.state.dailyGoalAchieved = true;
        }
      }
  
      getRemainingTimeText(task) {
        if (task.paused) return "Paused";
        const remaining = Math.max(task.totalDuration - task.activeDuration, 0);
        const minutes = Math.floor(remaining / 60000);
        const seconds = Math.floor((remaining % 60000) / 1000);
        return minutes === 0 ? `${seconds} seconds left` : `${minutes} minutes ${seconds} seconds left`;
      }
  
      renderActiveTasks() {
        const activeTasks = this.state.tasks.filter(task => !task.completed && !task.aborted);
        if (activeTasks.length === 0) {
          this.taskList.innerHTML = `<p class="empty">No active missions. Add one!</p>`;
          return;
        }
        this.taskList.innerHTML = activeTasks.map(task => `
          <div class="task-item" data-id="${task.id}">
            <div>
              <div class="priority-tag ${task.priority}">${task.priority.toUpperCase()}</div>
              <span class="task-text" id="taskText-${task.id}">${task.text}</span>
              <input type="text" class="edit-input" id="editInput-${task.id}" style="display:none;" value="${task.text}">
              <div class="deadline" id="deadline-${task.id}">
                ${this.getRemainingTimeText(task)}
              </div>
              <div class="progress-bar">
                <div class="progress" id="progress-${task.id}" style="width: ${task.progress}%"></div>
              </div>
            </div>
            <div class="task-actions">
              <button class="complete-task" data-id="${task.id}">✓</button>
              <button class="abort-task" data-id="${task.id}">✕</button>
              <button class="edit-task" data-id="${task.id}">Edit</button>
              <button class="save-task" data-id="${task.id}" style="display:none;">Save</button>
              ${task.paused 
                ? `<button class="resume-task" data-id="${task.id}">Resume</button>` 
                : `<button class="pause-task" data-id="${task.id}">Pause</button>`}
            </div>
          </div>
        `).join('');
      }
  
      renderTaskHistory() {
        const completedTasks = this.state.tasks.filter(task => task.completed)
                                  .sort((a, b) => b.startTime - a.startTime);
        const abortedTasks = this.state.tasks.filter(task => task.aborted)
                                  .sort((a, b) => b.startTime - a.startTime);
  
        let html = `<h3>Completed Missions</h3>`;
        if (completedTasks.length === 0) {
          html += `<p class="empty">No completed missions yet.</p>`;
        } else {
          html += completedTasks.map(task => {
            const diff = task.actualCompletionTime - task.startTime;
            const minutes = Math.floor(diff / 60000);
            const seconds = Math.floor((diff % 60000) / 1000);
            const timingInfo = `Completed in ${minutes} min ${seconds} sec (planned: ${task.time} min)`;
            return `
              <div class="task-item completed" data-id="${task.id}">
                <div>
                  <div class="priority-tag ${task.priority}">${task.priority.toUpperCase()}</div>
                  <span>${task.text}</span>
                  <div class="extra-details">
                    <div>Started: ${new Date(task.startTime).toLocaleString()}</div>
                    <div>${timingInfo}</div>
                  </div>
                </div>
                <div>
                  <button class="delete-task" data-id="${task.id}">✕</button>
                </div>
              </div>
            `;
          }).join('');
        }
  
        html += `<h3>Aborted Missions</h3>`;
        if (abortedTasks.length === 0) {
          html += `<p class="empty">No aborted missions yet.</p>`;
        } else {
          html += abortedTasks.map(task => {
            const timingInfo = 'Aborted at ' + new Date(task.abortTime).toLocaleTimeString();
            return `
              <div class="task-item aborted" data-id="${task.id}">
                <div>
                  <div class="priority-tag ${task.priority}">${task.priority.toUpperCase()}</div>
                  <span>${task.text}</span>
                  <div class="extra-details">
                    <div>Started: ${new Date(task.startTime).toLocaleString()}</div>
                    <div>${timingInfo}</div>
                  </div>
                </div>
                <div>
                  <button class="delete-task" data-id="${task.id}">✕</button>
                </div>
              </div>
            `;
          }).join('');
        }
  
        const totalHistory = completedTasks.length + abortedTasks.length;
        if (totalHistory > this.maxHistoryCount) {
          html += `<button id="downloadHistoryBtn" class="download-history-btn">Download and Clear History</button>`;
        }
        this.taskHistory.innerHTML = html;
  
        const downloadBtn = document.getElementById('downloadHistoryBtn');
        if (downloadBtn) {
          downloadBtn.addEventListener('click', () => this.downloadAndClearHistory());
        }
      }
  
      renderNotes() {
        if (this.state.notes.length === 0) {
          this.noteHistory.innerHTML = `<p class="empty">No encrypted notes yet.</p>`;
          return;
        }
        this.noteHistory.innerHTML = this.state.notes.map(note => `
          <div class="note-item" data-id="${note.id}">
            <div>
              <div class="timestamp">${note.timestamp}</div>
              <div>${note.showDecrypted ? atob(note.text) : note.text}</div>
            </div>
            <button class="toggle-note" data-id="${note.id}">${note.showDecrypted ? 'Hide' : 'Show'}</button>
          </div>
        `).join('');
      }
  
      updateUI() {
        this.renderActiveTasks();
        this.renderTaskHistory();
        this.renderNotes();
      }
  
      toggleHistory() {
        if (this.taskHistoryWrapper.classList.contains('open')) {
          this.taskHistoryWrapper.classList.remove('open');
          this.toggleHistoryBtn.textContent = "Show Task History";
        } else {
          this.taskHistoryWrapper.classList.add('open');
          this.toggleHistoryBtn.textContent = "Hide Task History";
        }
      }
  
      toggleNotes() {
        const notesContainer = document.getElementById("notesContainer");
        if (notesContainer.style.display === "none") {
          notesContainer.style.display = "block";
          this.toggleNotesBtn.textContent = "Hide Notes";
        } else {
          notesContainer.style.display = "none";
          this.toggleNotesBtn.textContent = "Show Notes";
        }
      }
  
      toggleSettings() {
        if (this.settingsContainer.style.display === "none") {
          this.settingsContainer.style.display = "block";
        } else {
          this.settingsContainer.style.display = "none";
        }
      }
  
      clearHistory() {
        this.state.tasks = this.state.tasks.filter(task => !task.completed && !task.aborted);
        this.historyExpanded = false;
        this.updateUI();
        this.saveState();
        this.showAchievement('Task history cleared!');
      }
  
      resetDailyPoints() {
        this.state.dailyPoints = 0;
        this.state.dailyGoalAchieved = false;
        this.updateRewardPointsDisplay();
        this.saveState();
        this.showAchievement('Daily points reset!');
      }
  
      editTask(id) {
        const taskTextElem = document.getElementById(`taskText-${id}`);
        const editInput = document.getElementById(`editInput-${id}`);
        const editBtn = document.querySelector(`.edit-task[data-id="${id}"]`);
        const saveBtn = document.querySelector(`.save-task[data-id="${id}"]`);
        if (taskTextElem && editInput && editBtn && saveBtn) {
          taskTextElem.style.display = "none";
          editInput.style.display = "inline-block";
          editBtn.style.display = "none";
          saveBtn.style.display = "inline-block";
        }
      }
  
      saveEditedTask(id) {
        const editInput = document.getElementById(`editInput-${id}`);
        const taskTextElem = document.getElementById(`taskText-${id}`);
        const editBtn = document.querySelector(`.edit-task[data-id="${id}"]`);
        const saveBtn = document.querySelector(`.save-task[data-id="${id}"]`);
        if (editInput && taskTextElem && editBtn && saveBtn) {
          const newText = editInput.value.trim();
          if (newText) {
            const task = this.state.tasks.find(t => t.id === id);
            task.text = newText;
            this.saveState();
            this.updateUI();
          }
        }
      }
  
      // Pause / Resume functionality using activeDuration tracking
      pauseTask(id) {
        const task = this.state.tasks.find(t => t.id === id);
        if (task && !task.paused && !task.completed && !task.aborted) {
          task.paused = true;
          task.pauseStart = Date.now();
          this.updateUI();
          this.saveState();
          this.showAchievement('Timer paused.');
        }
      }
  
      resumeTask(id) {
        const task = this.state.tasks.find(t => t.id === id);
        if (task && task.paused && !task.completed && !task.aborted) {
          // On resume, update lastActiveTimestamp so that paused duration is not added
          task.paused = false;
          task.lastActiveTimestamp = Date.now();
          task.pauseStart = null;
          this.updateUI();
          this.saveState();
          this.showAchievement('Timer resumed.');
        }
      }
  
      // Download & clear history if threshold exceeded
      downloadAndClearHistory() {
        const historyData = this.state.tasks.filter(task => task.completed || task.aborted);
        const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(historyData, null, 2));
        const downloadAnchorNode = document.createElement('a');
        downloadAnchorNode.setAttribute("href", dataStr);
        downloadAnchorNode.setAttribute("download", "history_" + new Date().toISOString() + ".json");
        document.body.appendChild(downloadAnchorNode);
        downloadAnchorNode.click();
        downloadAnchorNode.remove();
  
        this.state.tasks = this.state.tasks.filter(task => !(task.completed || task.aborted));
        this.saveState();
        this.updateUI();
        this.showAchievement('History downloaded and cleared!');
      }
  
      // Update loop using activeDuration tracking
      startProgressUpdateLoop() {
        setInterval(() => {
          const now = Date.now();
          this.state.tasks.forEach(task => {
            if (!task.completed && !task.aborted) {
              if (task.paused) {
                const deadlineElem = document.getElementById(`deadline-${task.id}`);
                if (deadlineElem) {
                  deadlineElem.textContent = "Paused";
                }
              } else {
                // Update activeDuration only when not paused
                task.activeDuration += now - task.lastActiveTimestamp;
                task.lastActiveTimestamp = now;
                const progress = Math.min((task.activeDuration / task.totalDuration) * 100, 100);
                task.progress = progress;
                const progressElem = document.getElementById(`progress-${task.id}`);
                if (progressElem) {
                  progressElem.style.width = `${progress}%`;
                }
                const deadlineElem = document.getElementById(`deadline-${task.id}`);
                if (deadlineElem) {
                  deadlineElem.textContent = progress < 100 ? this.getRemainingTimeText(task) : 'Completed';
                }
                if (this.config.voiceEnabled) {
                  if (!task.beep50 && progress >= 50) {
                    task.beep50 = true;
                    console.log(`50% reached for task ${task.id}.`);
                    this.playSound('fifty');
                  }
                  if (!task.beep70 && progress >= 70) {
                    task.beep70 = true;
                    console.log(`70% reached for task ${task.id}.`);
                    this.playSound('seventy');
                  }
                  if (!task.beep90 && progress >= 90) {
                    task.beep90 = true;
                    console.log(`90% reached for task ${task.id}.`);
                    this.playSound('ninety');
                  }
                }
                if (progress >= 100 && !task.completed && !task.awaitingResponse) {
                  // When progress completes, prompt the user once.
                  task.awaitingResponse = true;
                  this.playSound('timer');
                  // Request notification permission properly before showing notification
                  if (Notification.permission !== "granted") {
                    Notification.requestPermission().then(permission => {
                      if (permission === "granted") {
                        new Notification("Task Timer Finished", { 
                          body: `Task: ${task.text}\nDid you complete the task?`
                        });
                      }
                    });
                  } else {
                    new Notification("Task Timer Finished", { 
                      body: `Task: ${task.text}\nDid you complete the task?`
                    });
                  }
                  const userConfirmed = confirm(`The timer for "${task.text}" is finished.\nDid you complete the task?`);
                  if (userConfirmed) {
                    this.completeTask(task.id);
                  } else {
                    alert("Task remains unfinished. You can manually abort it if needed.");
                  }
                }
              }
            }
          });
        }, 500);
      }
  
      startBeepReminder() {
        if (this.beepTimeout) {
          clearTimeout(this.beepTimeout);
        }
        const beepFunction = () => {
          const activeTasks = this.state.tasks.filter(task => !task.completed && !task.aborted);
          if (activeTasks.length > 0) {
            console.log("Beep! 🔊");
            this.playSound('beep');
          }
          this.beepTimeout = setTimeout(beepFunction, 7 * 60 * 1000);
        };
        beepFunction();
      }
  
      startPausedReminder() {
        // Plays reminder sound every 3 minutes if any task is paused
        if (this.pausedReminderTimeout) {
          clearTimeout(this.pausedReminderTimeout);
        }
        const reminderFunction = () => {
          const pausedTasks = this.state.tasks.filter(task => task.paused && !task.completed && !task.aborted);
          if (pausedTasks.length > 0) {
            console.log("Paused Reminder! 🔔");
            this.playSound('reminder');
          }
          this.pausedReminderTimeout = setTimeout(reminderFunction, 3 * 60 * 1000);
        };
        reminderFunction();
      }
  
      playSound(name) {
        if (this.sounds[name]) {
          this.sounds[name].currentTime = 0;
          this.sounds[name].play().catch((error) => {
            console.error("Error playing sound:", error);
          });
        } else {
          console.warn("Sound not found:", name);
        }
      }
  
      showAchievement(message) {
        const achievement = document.createElement('div');
        achievement.textContent = message;
        achievement.style.position = 'fixed';
        achievement.style.top = '20px';
        achievement.style.right = '20px';
        achievement.style.background = '#ff69b4';
        achievement.style.padding = '10px 20px';
        achievement.style.borderRadius = '5px';
        achievement.style.boxShadow = '0 0 10px rgba(255,105,180,0.7)';
        achievement.style.zIndex = 1000;
        document.body.appendChild(achievement);
        setTimeout(() => achievement.remove(), 3000);
      }
  
      showCelebration(message) {
        for (let i = 0; i < 3; i++) {
          setTimeout(() => {
            confetti({
              particleCount: 100,
              spread: 120,
              origin: { x: Math.random(), y: Math.random() }
            });
          }, i * 200);
        }
        const flash = document.createElement('div');
        flash.style.position = 'fixed';
        flash.style.top = '0';
        flash.style.left = '0';
        flash.style.width = '100%';
        flash.style.height = '100%';
        flash.style.background = 'rgba(255,255,255,0.3)';
        flash.style.zIndex = '999';
        flash.style.opacity = '1';
        flash.style.transition = 'opacity 1s ease-out';
        document.body.appendChild(flash);
        setTimeout(() => { flash.style.opacity = '0'; }, 100);
        setTimeout(() => { flash.remove(); }, 1100);
  
        const celebration = document.createElement('div');
        celebration.textContent = message;
        celebration.style.position = 'fixed';
        celebration.style.top = '50%';
        celebration.style.left = '50%';
        celebration.style.transform = 'translate(-50%, -50%) scale(0)';
        celebration.style.background = 'linear-gradient(45deg, #ff0080, #ff8c00)';
        celebration.style.padding = '40px 60px';
        celebration.style.borderRadius = '15px';
        celebration.style.boxShadow = '0 0 40px rgba(255,255,255,0.8)';
        celebration.style.zIndex = '1000';
        celebration.style.fontSize = '3rem';
        celebration.style.color = '#ffffff';
        celebration.style.transition = 'transform 0.5s ease-out, opacity 0.5s ease-out';
        celebration.style.opacity = '0';
        document.body.appendChild(celebration);
        setTimeout(() => {
          celebration.style.transform = 'translate(-50%, -50%) scale(1)';
          celebration.style.opacity = '1';
        }, 100);
        setTimeout(() => {
          celebration.style.transform = 'translate(-50%, -50%) scale(0.5)';
          celebration.style.opacity = '0';
        }, 2000);
        setTimeout(() => { celebration.remove(); }, 2500);
      }
  
      requestNotificationPermission() {
        if ("Notification" in window && Notification.permission !== "granted") {
          Notification.requestPermission();
        }
      }
  
      initBackgroundAudio() {
        if (window.AudioContext || window.webkitAudioContext) {
          try {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            const audioCtx = new AudioContext();
            if (audioCtx.state === 'suspended') {
              audioCtx.resume();
            }
          } catch (e) {
            console.error("AudioContext initialization failed:", e);
          }
        }
      }
  
      setupVisibilityChange() {
        document.addEventListener('visibilitychange', () => {
          if (document.visibilityState === 'hidden') {
            if (Notification.permission === "granted") {
              new Notification("You're off-task", {
                body: "Come back and complete your missions!"
              });
            }
          }
          if (document.visibilityState === 'visible') {
            if (window.AudioContext || window.webkitAudioContext) {
              const AudioContext = window.AudioContext || window.webkitAudioContext;
              const audioCtx = new AudioContext();
              if (audioCtx.state === 'suspended') {
                audioCtx.resume();
              }
            }
          }
        });
      }
  
      componentWillUnmount() {
        if (this.beepTimeout) {
          clearTimeout(this.beepTimeout);
        }
      }
    }
  
    // DOMContentLoaded: Initialize the app and ensure audio unlock on first user interaction
    document.addEventListener('DOMContentLoaded', () => {
      const app = new DarkProductivityApp();
  
      // On first user interaction (click or touchstart), unlock audio elements
      const unlockHandler = () => {
        app.unlockAudio();
      };
      document.body.addEventListener('click', unlockHandler, { once: true });
      document.body.addEventListener('touchstart', unlockHandler, { once: true });
  
      if (typeof particlesJS !== "undefined") {
        particlesJS('particles-js', {
          particles: {
            number: { value: 150 },
            color: { value: '#8a2be2' },
            shape: { type: 'circle' },
            opacity: { value: 0.5 },
            size: { value: 2 },
            move: {
              enable: true,
              speed: 1.5,
              direction: 'none',
              random: true,
              straight: false,
              out_mode: 'bounce',
              bounce: true
            }
          },
          interactivity: {
            detect_on: 'canvas',
            events: {
              onhover: { enable: true, mode: 'grab' },
              onclick: { enable: true, mode: 'push' },
              resize: true
            }
          }
        });
      } else {
        console.error("particlesJS is not loaded!");
      }
    });
  
    document.addEventListener("visibilitychange", () => {
      if (document.hidden) {
          console.log("Page is in background");
      } else {
          console.log("Page is active");
      }
    });
  
    document.addEventListener("click", () => {
      Notification.requestPermission().then(permission => {
          if (permission === "granted") {
              new Notification("Website will run in the background!");
          }
      });
    });
  </script>
  
  
  
  
  
  
  
</body>
</html>
